# Домашнє завдання №4

# Завдання 1

## Порівняльний аналіз алгоритмів сортування за часом виконання

- Написання алгоритмів сортування
- Тестування написаних алгоритмів та вбудованих функцій Python sort та sorted на різних наборах даних 
- Розрахування часу різних алгоритмів сортування за допомогою модуля timeit
- Емпірична перевірка теоретичної оцінки складності алгоритмів та швидкодії

## Емпірична перевірка теоретичної оцінки складності алгоритмів сортування

### Вихідні дані:
Було виміряно час виконання наступних алгоритмів:
- bubble_sort
- insertion_sort
- selection_sort
- quick_sort
- merge_sort
- shell_sort
- radix_sort
- Вбудовані алгоритми Python: list.sort() та sorted()

Тестування виконувалося на масивах довжиною: 10, 100, 5000, 10000, 50000 елементів. Для кожного розміру використовувався той самий масив для всіх функцій, щоб забезпечити коректність порівняння.

### Результати вимірювань

Перший набір масивів:
```
      Function          10         100        5000       10000       50000
   bubbble_sort    0.000016    0.000438    1.310299    5.374469  135.679485
 insertion_sort    0.000025    0.000262    0.629541    2.539632   63.447851
 selection_sort    0.000017    0.000344    0.634239    2.440230   57.638552
     quick_sort    0.000060    0.000318    0.007728    0.012481    0.057455
     merge_sort    0.000042    0.000162    0.012802    0.042511    0.162357
     shell_sort    0.000017    0.000099    0.011164    0.027504    0.157522
     radix_sort    0.000048    0.000117    0.005460    0.012350    0.054643
    python_sort    0.000008    0.000013    0.000739    0.001412    0.007464
  python_sorted    0.000004    0.000012    0.000773    0.001462    0.007623
```

Другий набір масивів:
```

       Function          10         100        5000       10000       50000
   bubbble_sort    0.000017    0.000420    1.380023    8.081597  283.922974
 insertion_sort    0.000026    0.000369    1.355993    5.401501   80.340218
 selection_sort    0.000021    0.000239    0.542943    2.246475  103.090383
     quick_sort    0.000042    0.000303    0.010358    0.024661    0.112532
     merge_sort    0.000053    0.000426    0.030350    0.069865    0.355642
     shell_sort    0.000029    0.000158    0.026344    0.054475    0.326355
     radix_sort    0.000070    0.000186    0.012091    0.023176    0.119928
    python_sort    0.000011    0.000029    0.002275    0.003936    0.014500
  python_sorted    0.000011    0.000023    0.001122    0.002848    0.011928

```
## Емпірична перевірка теоретичної складності

### Вбудовані алгоритми Python — абсолютні переможці

Python sort() і sorted() поєднують merge_sort + insertion_sort, оптимізовані під реальні дані і на практиці у десятки разів швидші будь-яких інших ручних реалізацій.

### На невеликих масивах гарні результати демонструють:
- Bubble sort
- Selection sort
- Shell sort
- Insertion sort

Натомість значно програють:
- Quick sort через витрати рекурсії.
- Radix sort через створення додаткових масивів.
- Merge sort через копіювання підмасивів.

### На великих масивах:
- Radix sort — лінійний для фіксованої розрядності і один із найшвидших.
- Quick sort — найшвидший алгоритм, якщо підібрано правильний pivot.
- Shell sort — демонструє хороші практичні результати, хоча складність залежить від послідовності інкрементів.
- Merge sort — стабільний, гарантує O(n log n), але повільніший за quick_sort через виділення пам’яті.

## Висновки

Теоретична складність повністю співпадає з практичними результатами.
Алгоритми O(n²) програють у сотні разів на великих масивах.

Найкращі серед ручних реалізацій згідно результатів:
- ```bubble_sort``` та ```selection_sort``` — на малих масивах
- ```radix_sort``` та ```quick_sort``` — на великих масивах

Гібридні алгоритми виявились найефективнішими. Поєднання сортування злиттям і вставками робить Timsort найкращим варіантом для реальних задач (```list.sort, sorted(list)```). 

# Завдання 2

## Сортування та об'єднання декількох несортованих списків

Дано k відсортованих списків цілих чисел. Завдання — об'єднати їх у один відсортований список (алгоритм сортування злиттям). Функція merge_k_lists приймає на вхід список відсортованих списків та повертає відсортований список.

Приклад очікуваного результату:

```
lists = [[1, 4, 5], [1, 3, 4], [2, 6]]
merged_list = merge_k_lists(lists)
print("Відсортований список:", merged_list)
```

Виведення:
```
Відсортований список: [1, 1, 2, 3, 4, 4, 5, 6]
```